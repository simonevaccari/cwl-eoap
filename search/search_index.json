{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"The Application Package and CWL as a solution for Earth Observation portability","text":"<p>The Application Package is a document that describes the data processing application by providing information about the parameters, software item, executable, dependencies and metadata. </p> <p>The Application Package document ensures that the application is portable among all supporting execution and processing scenarios including the deployment in a Machine-To-Machine (M2M) scenario. </p> <p>Most importantly, the Application Package information model allows the deployment of the application as an OGC API\u2009-\u2009Processes (OGC 18-062) compliant web service.</p> <p>The Application Package includes the following information:</p> <ul> <li>Reference to the executable block that implements the Application functionality</li> <li>Description of its input/output interface</li> </ul> <p>The Application Package uses:</p> <ul> <li>the Common Workflow Language (CWL) Workflow specification as an encoding to describe the Application, its parameters and data flow</li> <li>the CWL CommandLineTool specification to describe command-line tools, their runtime environments, their arguments and their invocation within containers.</li> </ul> <p>This documentation provides the OGC activities that lead to the adoption of the Common Workflow Language as the open standard for supporting the packaging of Earth Observation applications.</p>"},{"location":"usage-scenarios/","title":"Application Package Usage Scenarios","text":"<p>The application package provides a well-defined set of procedures to allow \u201cbuild to run\u201d operations. </p> <p>It covers five different usage scenarios from application testing, validation, and deployment to execution in production that enables:</p> <ul> <li>Alice to package an application</li> <li>Bob to script the execution of application</li> <li>Eric to deploy an application on platform Z</li> <li>Platform Z to accept the deployment of a new process</li> <li>Platform Z to execute a process with specific parameters</li> </ul> <p>The scenarios cover the three \"build to run\" operations: Build, Deploy and Run.</p>"},{"location":"usage-scenarios/#build","title":"Build","text":"<p>Alice builds a container image with her Application and command line tool(s) and respective runtime environments, publishes the container image on a repository and writes the Application Package document with a workflow that invokes the command line tool(s) included in the image.</p> <p>For Alice, the Application Package is a portable and executable document that:</p> <ul> <li>References the container image</li> <li>Describes the input parameters of the Application</li> <li>Maps the input parameters to the command line tool(s) arguments</li> </ul> <p>Bob wants to run Alice\u2019s application and scripts the application with different input parameters in his local machine. He uses two tools to script the execution: a container engine (e.g. Docker, podman) and a CWL runner. </p> <p>The container images used are a controlled execution environment and they're the same used by Alice to build and test the application.</p> <p>For Bob, the Application Package is a portable and executable document that:</p> <ul> <li>Is used by the CWL runner to mount the volumes for the inputs and outputs for the container run</li> <li>Is used by the CWL runner to invoke the CLI in a specified way with parameters passed as YAML.</li> <li>Isolates the process with no environments configured on Bob\u2019s machine</li> </ul>"},{"location":"usage-scenarios/#deploy","title":"Deploy","text":"<p>Eric wants to deploy Alice\u2019s Application Package as a new Processing Service in Platform Z where he has authorization rights.</p> <p>He uses the Application Package document to create an OGC API\u2009\u2014\u2009Processes Transaction Extension request to dynamically add a process to a deployed OGC API\u2009\u2014\u2009Processes server instance.</p> <p>For Eric, the Application Package is a portable and executable document that:</p> <ul> <li>Maps the application input parameters to OGC API\u2009\u2014\u2009Processes Input Parameters</li> <li>Identifies the container image to be deployed and corresponding execution unit</li> <li>Registers an application in a platform as a process within an OGC API\u2009\u2014\u2009Processes server instance</li> </ul> <p>Platform Z receives an OGC API\u2009\u2014\u2009Processes deployment from Eric. The platform uses the Application Package CWL to create a new process in the OGC API\u2009\u2014\u2009Processes server instance. </p> <p>For the Platform Z, the Application Package is a document that:</p> <ul> <li>Defines the process metadata (including the Input Parameters)</li> <li>Identifies the container image to be deployed and corresponding execution unit</li> <li>Creates a new process in the OGC API\u2009\u2014\u2009Processes instance</li> </ul>"},{"location":"usage-scenarios/#run","title":"Run","text":"<p>Platform Z receives an OGC API\u2009\u2014\u2009Processes execution request for Eric\u2019s deployed process.</p> <p>The platform uses the Application Package CWL to retrieve the specified container image, create the container, map the instantiated parameters with the execution values and execute the application.</p> <p>For the Platform Z, the Application Package is a portable and executable document that:</p> <ul> <li>Describes the application metadata of the process</li> <li>Maps the OGC API\u2009\u2014\u2009Processes input parameters to the application input parameters</li> <li>Identifies the container image to be deployed, the corresponding execution unit, to monitor the execution and retrieve the results</li> </ul>"},{"location":"yaml/","title":"Understanding YAML syntax","text":""},{"location":"yaml/#key-value-pairs","title":"Key-Value Pairs","text":"<p>Fundamentally, a file written in YAML consists of a set of key-value pairs.</p> <p>Each pair is written as <code>key: value</code>, where whitespace after the <code>:</code> is optional.</p> <p>Key names in CWL files should not contain whitespace - We use camelCase for multi-word key names that have special meaning in the CWL specification and underscored key names otherwise.</p> <p>For example:</p> <pre><code>first_name: Bilbo\nlast_name:  Baggins\nage_years:  111\nhome:       Bag End, Hobbiton\n</code></pre> <p>The YAML above defines four keys - <code>first_name</code>, <code>last_name</code>, <code>age_years</code>, and <code>home</code> - with their four respective values.</p> <p>Values can be:</p> <ul> <li>character strings</li> <li>numeric (integer, floating point, or scientific representation)</li> <li>Boolean (<code>true</code> or <code>false</code>)</li> </ul> <p>or more complex nested types (see below).</p> <p>Values may be wrapped in quotation marks but be aware that this may change the way that they are interpreted i.e. <code>\"1234\"</code> will be treated as a character string, while <code>1234</code> will be treated as an integer.</p> <p>This distinction can be important,for example when describing parameters to a command. In CWL all parts of <code>baseCommand</code> must be strings so, if you want to specify a fixed numeric value to a command,make sure that you wrap that numeric value in quotes: <code>baseCommand: [echo, \"42\"]</code>.</p>"},{"location":"yaml/#comments","title":"Comments","text":"<p>You may use <code>#</code> to add comments to your CWL and parameter files.</p> <p>Any characters to the right of <code>#</code> will be ignored by the program interpreting the YAML.</p> <p>For example:</p> <pre><code>first_name: Bilbo\nlast_name:  Baggins\nage_years:  111\n# this line will be ignored by the interpreter\nhome:       Bag End, Hobbiton # this is ignored too\n</code></pre> <p>If there is anything on the line before the comment, be sure to add at least one space before the <code>#</code>!</p>"},{"location":"yaml/#maps","title":"Maps","text":"<p>When describing a tool or workflow with CWL, it is usually necessary to construct more complex, nested representations.</p> <p>Called maps, these hierarchical structures are described in YAML by providing additional key-value pairs as the value of any key.</p> <p>These pairs (sometimes referred to as \"children\") are written on new lines under the key to which they belong (the \"parent\"), and should be indented with two spaces (\u21e5tab characters are not allowed).</p> <p>For example:</p> <pre><code>cwlVersion: v1.0\nclass: CommandLineTool\nbaseCommand: echo\ninputs: # this key has an object value\n  example_flag: # so does this one\n    type: boolean\n    inputBinding: # and this one too\n      position: 1\n      prefix: -f\n</code></pre> <p>The YAML above illustrates how you can build up complex nested object descriptions relatively quickly.</p> <p>The <code>inputs</code> map contains a single key, <code>example_flag</code>, which itself contains two keys, <code>type</code> and <code>inputBinding</code>, while one of these children, <code>inputBinding</code>, contains a further two key-value pairs (<code>position</code> and <code>prefix</code>).</p> <p>See the Arrays section below for more information about providing multiple values/key-value pairs for a single key.</p> <p>For comparison with the example YAML above, here is a graphical representation of the <code>inputs</code> object it describes.</p>  graph TD   inputs --&gt; example_flag   example_flag --&gt; type   type --- bool((boolean))   example_flag --&gt; inputBinding   inputBinding --&gt; position   inputBinding --&gt; prefix   position --- posval((1))   prefix --- prefval(('-f'))"},{"location":"yaml/#arrays","title":"Arrays","text":"<p>In certain circumstances it is necessary to provide multiple values or objects for a single key.</p> <p>As we've already seen in the Maps section above, more than one key-value pair can be mapped to a single key.</p> <p>However, it is also possible to define multiple values for a key without having to provide a unique key for each value.</p> <p>We can achieve this with an array, where each value is defined on its own line and preceded by <code>-</code>.</p> <p>For example:</p> <pre><code>touchfiles:\n  - foo.txt\n  - bar.dat\n  - baz.txt\n</code></pre> <p>and a more complex example combining maps and arrays:</p> <pre><code>exclusive_parameters:\n  type:\n    - type: record\n      name: itemC\n      fields:\n        itemC:\n          type: string\n          inputBinding:\n            prefix: -C\n    - type: record\n      name: itemD\n      fields:\n        itemD:\n          type: string\n          inputBinding:\n            prefix: -D\n</code></pre>"},{"location":"yaml/#json-style","title":"JSON Style","text":"<p>YAML is based on JavaScript Object Notation (JSON) and maps and arrays can also be defined in YAML using the native JSON syntax.</p> <p>For example:</p> <pre><code>touchfiles: [foo.txt, bar.dat, baz.txt] # equivalent to first Arrays example\n</code></pre> <p>and:</p> <pre><code># equivalent to the `inputs` example in \"Maps\" above\ninputs: {example_flag: {type: boolean, inputBinding: {position: 1, prefix: -f}}}\n</code></pre> <p>Native JSON can be useful to indicate where a field is being left intentionally empty (such as <code>[]</code> for an empty array), and where it makes more sense for the values to be located on the same line (such as when providing option flags and their values in a shell command).</p> <p>However, as the second example above shows, it can severely affect the readability of a YAML file and should be used sparingly.</p>"},{"location":"yaml/#reference","title":"Reference","text":"<p>This page is the same as http://www.commonwl.org/user_guide/yaml/</p>"},{"location":"background/applications-pilot/","title":"OGC EO Applications Pilot","text":"<p>The OGC Innovation Program's Earth Observation Applications Pilot, conducted between December 2019 and July 2020, investigated the software architecture initially developed through OGC Testbeds 13-15. This architecture facilitated the deployment and execution of externally developed applications on Earth Observation (EO) data and processing platforms.</p> <p>The pilot program served as an evaluation of the interoperability frameworks previously established in OGC Testbeds 13 to 15, proving to be a foundational step for conducting maturity assessments within operational environments. During the pilot, further enhancements and precise definitions were crafted, which refined the process for deploying and executing applications across a variety of platforms with nly minimal modifications required.</p> <p>The Pilot validated the strategy of using Docker for secure and efficient application packaging, and HTTP Web APIs or Web Services for managing and executing applications. Moreover, the pilot defined clear application patterns that govern data inputs and outputs, reinforced the use of the Common Workflow Language (CWL) for detailed application description, execution, and workflow construction. It also endorsed the adoption of the SpatioTemporal Asset Catalog (STAC) to serve as a comprehensive data manifest, delineating the necessary inputs and outputs for applications. These advancements collectively enhance the deployment flexibility and interoperability of applications within diverse EO data ecosystems.</p> <p>The conclusion of the OGC Earth Observation Applications Pilot emphasized the need for standardized subsets of the Common Workflow Language (CWL) that all platforms should support. This standardization was reckoned essential to ensure that application developers experience consistency and predictability when deploying their applications across different platforms. As a result, the pilot advocated for the creation of an OGC Best Practice document that would outline the use of CWL within application packages.</p> <p>This proposed Best Practice document would aim to serve as a comprehensive guide, addressing the diverse application design patterns explored during the pilot. It would provide detailed guidelines for the automated generation of CWL, enabling a more streamlined and efficient development process for EO applications. This initiative would seek to enhance the interoperability and usability of Earth Observation data and processing platforms by leveraging CWL\u2019s robust framework for describing and executing workflows, thereby fostering a more unified and effective approach to application development within the geospatial community.</p>"},{"location":"background/background/","title":"Background","text":"<p>How was CWL selected as the open standard to support the packaging of Earth Observation applications?</p> <p>There are several activities and these are depicted below:</p> flowchart LR     subgraph References[\"`**References**`\"]       subgraph Testbed-13         tb13[\"`EP Application Package Engineering Report (17-023)             Application Deployment and Execution Service Engineering Report (17-024)             Cloud Engineering Report (17-035)`\"]     end     subgraph Testbed-14         tb14[\"`Application Package Engineering Report (18-049r1)             ADES &amp; EMS Results and Best Practices Engineering Report (18-050r1)`\"]     end     subgraph Testbed-15         tb15[\"`Catalogue and Discovery Engineering Report (19-020r1)`\"]     end     end     subgraph eoap[\"`**Earth Observation Applications Pilot**`\"]         eoaper[\"`20-042 Terradue Engineering Report                 20-045 CRIM Engineering Report                 20-038 European Union Satellite Centre Engineering Report                 20-043 EOX Consortium Engineering Report                 20-037 Pixalytics Engineering Report                 20-034 Spacebel Engineering Report`\"]         summary-er[\"EO Applications Pilot          Summary Engineering Report (20-073)\"]         eoaper --&gt; summary-er     end     Testbed-13 --&gt; eoap     Testbed-14 --&gt; eoap     Testbed-15 --&gt; eoap     summary-er --&gt; bp[\"`Best Practice for Earth Observation Application Package (20-089)`\"]      bp --&gt; tb16[\"`Testbed-16: Earth Observation Application Packages with Jupyter Notebooks`\"]     bp --&gt; tb17[\"`Testbed 17: COG/Zarr Evaluation Engineering Report`\"]     bp --&gt; tb18[\"`Testbed-18: Testbed-18: Reproducible FAIR Best Practices Engineering Report`\"] <p>This section provides the background activities that lead to this selection.</p>"},{"location":"background/eoap-best-practice/","title":"Best Practice for EO Application Package","text":""},{"location":"background/eoap-best-practice/#the-ogc-best-practice-for-earth-observation-application-packaging","title":"The OGC Best Practice for Earth Observation Application Packaging","text":"<p>TODO</p>"},{"location":"background/previous-ogc-testbeds/","title":"Previous OGC Testbeds","text":"<p>The OGC initiatives in Testbed-13, Testbed-14, and Testbed-15 have pioneered the development of an advanced architectural framework designed to facilitate the ad-hoc deployment and execution of applications proximate to the data source. This strategic positioning minimizes data transfer, enhancing efficiency between data repositories and application processes.</p> <p>These testbeds laid the foundational design for an architecture that supports the encapsulation, deployment, and execution of Earth Observation Applications across distributed Cloud Platforms. This framework ensures that applications are efficiently integrated and managed within cloud environments, providing scalable solutions for Earth Observation data processing.</p> <p>Building on established OGC standards such as WPS (Web Processing Service) and OWS-Context, these testbed activities have refined the concept of Application Packages. These packages encapsulate data processing applications or workflows, allowing for streamlined deployment and execution across varied Cloud Platforms.</p> <p>The WPS service plays a pivotal role by enabling end-user portals and B2B client applications to submit processing parameters, initiate on-demand or systematic data processing requests, and establish data pipelines for retrieving the processed information.</p> <p>Each Application Package contains detailed specifications about the execution units or workflow scripts to be executed, along with configurations for parameterization or customization. This modular approach facilitates the precise tailoring of processing workflows to specific project needs.</p> <p>The architecture articulated in these testbeds integrates the Application Package with key services: the Execution Management Service (EMS) and the Application Deployment and Execution Service (ADES). The EMS orchestrates the deployment and invocation of processing services workflows, leveraging multiple deployment and execution platforms through WPS-T, a transactional extension of WPS. The ADES, in turn, functions as the execution engine, managing the application lifecycle previously configured as a WPS service by the EMS.</p> <p>The EMS orchestrates the application package across the selected ADES platform, managing the deployment and execution of workflow components either locally or remotely. It ensures a streamlined operation from deployment to execution, fostering a responsive and agile processing environment.</p> <p>Primary responsibilities of the ADES include:</p> <ul> <li>Validating and approving application deployment and execution requests from the EMS.</li> <li>Managing the execution of processes within the processing cluster, ensuring robust performance and reliability.</li> <li>Monitoring ongoing process execution to maintain operational integrity and performance.</li> <li>Retrieving and delivering processed results efficiently, ensuring data integrity and accessibility.</li> </ul> <p>Additionally, the ADES handles critical sub-steps such as the staging-in of input data and the staging-out of output data, essential for maintaining a seamless flow in data processing activities. This comprehensive approach not only enhances operational efficiency but also ensures that the architecture can support complex, data-intensive workflows in an optimized manner.</p>"},{"location":"best-practice/application/","title":"Application Best Practice","text":"<p>An Application that complies with the Best Practice for Earth Observation Application Package needs to be:</p> <ul> <li>Executable as a command-line tool.</li> <li>Delivered in a container image with all the necessary software, libraries and configuration files.</li> </ul> <p>Here we describe the best practices for Earth Observation applications:</p> <ul> <li>the command line tools</li> <li>how to consider input data, output data </li> <li>how to create a containers</li> </ul>"},{"location":"best-practice/application/#command-line","title":"Command line","text":"<p>The Application is executed as a command-line interface (CLI) tool that runs as a non-interactive executable program: it receives input arguments, performs a computation, and terminates after producing some output.</p> <p>The Application can have any number of command-line arguments.</p> <p>When executed, the Application working directory is also the Application output directory. Any file created by the Application should be added under that directory.</p>"},{"location":"best-practice/application/#hands-on","title":"Hands-on","text":"<p>Open the notebook 01 Command line</p>"},{"location":"best-practice/application/#container","title":"Container","text":"<p>The environment, libraries, binaries and configuration files necessary to execute the command-line tools need to be bundled in a container image.</p> <p>The example below shows how Docker, one of the available container engine solutions to deliver software in containers, defines all the necessary commands to assemble an image:</p> <pre><code>FROM docker.io/python:3.10-slim\n\nRUN pip install --no-cache-dir rasterio click pystac loguru pyproj shapely &amp;&amp; \\\n    python -c \"import rasterio\"\n\nADD app.py /app/app.py\n\nENTRYPOINT []\n</code></pre>"},{"location":"best-practice/application/#hands-on_1","title":"Hands-on","text":"<p>Open the notebook 02 Container</p>"},{"location":"best-practice/application/#requirement-classes","title":"Requirement classes","text":"<p>Requirement 1 req/app/cmd-line</p> <p>The Application SHALL be a non-interactive executable as a command-line application.</p> <p>Requirement 2 req/app/container</p> <p>The environment, libraries, binaries, executable and configuration files necessary to execute the Application SHALL be bundled in a container image.</p> <p>Requirement 3 req/app/registry</p> <p>The Application container image SHALL be accessible in a container registry.</p>"},{"location":"best-practice/package/","title":"Application Package Best Practice","text":"<p>A Package that complies with the OGC Best Practice for Earth Observation Application Package needs to:</p> <ul> <li>Be a valid CWL document with a single Workflow Class and at least one CommandLineTool Class</li> <li>Define the command-line and respective arguments and container for each CommandLineTool</li> <li>Define the Application parameters</li> <li>Define the Application Design Pattern</li> <li>Define the requirements for runtime environment</li> </ul> <p>The Workflow class steps field orchestrates the execution of the application command line and retrieves all the outputs of the processing steps.</p>"},{"location":"best-practice/package/#cwl-document","title":"CWL Document","text":"<p>The CWL Document references the Application parameters with the CWL class Workflow and the command lines tools and arguments with the CWL CommandLineTool classes.</p> <pre><code>cwlVersion: v1.1\n$graph:\n- class: Workflow\n  id: crop\n  ...\n\n- class: CommandLineTool\n  id: crop-cl\n  ...\n</code></pre>"},{"location":"best-practice/package/#command-line-tool","title":"Command-Line Tool","text":"<p>As stated previously, the command-line tool is a non-interactive executable program that reads some input, performs a computation, and terminates after producing some output.</p> <p>The CWL CommandLineTool class defines the actual interface of the command-line tool and its arguments according to the CWL CommandLineTool standard.</p> <p>The CWL explicitly supports the use of software container technologies, such as Docker or Podman, to enable portability of the underlying analysis tools. </p> <p>The Application Package needs to explicitly provide for each command-line tool the container requirements defining the container image needed.</p> <p>The CWL requirement <code>DockerRequirement</code> indicates that the component must be run in a container, and specifies how to fetch or build the image.</p> <pre><code>cwlVersion: v1.2\n\n$graph:\n- class: Workflow\n  id: crop\n  ...\n\n- class: CommandLineTool\n  id: crop-cl\n\n  requirements:\n    DockerRequirement:\n      dockerPull: localhost/crop:latest\n</code></pre> <p>The field inputs defines the list of input parameters of the command-line that control how to run the tool. Each parameter has an id for the name of parameter, and a type field describing what types of values are valid for that parameter (e.g. <code>string</code>, <code>int</code>, <code>double</code>, <code>null</code>, <code>File</code>, <code>Directory</code>, <code>Any</code>). Additionally, if there are command-line bindings not directly associated with input parameters (e.g. fixed values or environment run-time values), the field arguments can also be used.</p> <pre><code>cwlVersion: v1.2\n\n$graph:\n- class: Workflow\n  id: crop\n  ...\n\n- class: CommandLineTool\n  id: crop-cl\n\n  requirements:\n    DockerRequirement:\n      dockerPull: localhost/crop:latest\n\n  baseCommand: [\"python\", \"-m\", \"app\"]\n  arguments: []\n  inputs:\n    item:\n      type: string\n      inputBinding:\n          prefix: --input-item\n    aoi:\n      type: string\n      inputBinding:\n          prefix: --aoi\n    epsg:\n      type: string\n      inputBinding:\n          prefix: --epsg\n    band:\n      type: string\n      inputBinding:\n          prefix: --band\n  ...\n</code></pre> <p>When the command-line is executed under CWL, the starting working directory is the designated output directory. The underlying tool or script records its results in the form of files created in the output directory.</p> <p>All the outputs of the command line tool are retrieved at this level.</p> <pre><code>cwlVersion: v1.2\n\n$graph:\n- class: Workflow\n  id: crop\n  ...\n\n- class: CommandLineTool\n  id: crop-cl\n\n  requirements:\n    DockerRequirement:\n      dockerPull: localhost/crop:latest\n\n  baseCommand: [\"python\", \"-m\", \"app\"]\n  arguments: []\n  inputs:\n    item:\n      type: string\n      inputBinding:\n          prefix: --input-item\n    aoi:\n      type: string\n      inputBinding:\n          prefix: --aoi\n    epsg:\n      type: string\n      inputBinding:\n          prefix: --epsg\n    band:\n      type: string\n      inputBinding:\n          prefix: --band\n  outputs:\n    cropped:\n      outputBinding:\n          glob: '*.tif'\n      type: File\n</code></pre>"},{"location":"best-practice/package/#application","title":"Application","text":"<p>The CWL Workflow class defines the Application as an analysis task represented by a directed graph describing a sequence of operations that transform an input data set to output.</p> <p>The Workflow class includes four basic blocks: identification, inputs, steps and outputs.</p> <p>For the identification block, the CWL Workflow class supports the definition of a unique identifier (id), a short human-readable title (label) and a long human-readable description (doc) of the Application.</p> <pre><code>cwlVersion: v1.2\n$graph:\n- class: Workflow\n  id: main\n  label: Water bodies detection based on NDWI and the otsu threshold\n  doc: Water bodies detection based on NDWI and otsu threshold applied to a single Sentinel-2 COG STAC item\n</code></pre> <p>For the inputs, the CWL Workflow class supports the definition of the input parameters of the process. Each input parameter has a corresponding identifier (the field\u2019s name), title (label), abstract (doc) and a type (type) that is mandatory according to the CWL Workflow specification.</p> <pre><code>cwlVersion: v1.2\n$graph:\n- class: Workflow\n  id: main\n  label: Water bodies detection based on NDWI and the otsu threshold\n  doc: Water bodies detection based on NDWI and otsu threshold applied to a single Sentinel-2 COG STAC item\n  requirements: []\n  inputs:\n    aoi:\n      label: area of interest\n      doc: area of interest as a bounding box\n      type: string\n    epsg:\n      label: EPSG code\n      doc: EPSG code\n      type: string\n      default: \"EPSG:4326\"\n    bands:\n      label: bands used for the NDWI\n      doc: bands used for the NDWI\n      type: string[]\n      default: [\"green\", \"nir\"]\n    item:\n      doc: Reference to a STAC item\n      label: STAC item reference\n      type: string\n</code></pre> <p>The workflow is managed by the steps field of the Workflow class that links the corresponding parameters with arguments of the command-line class defined in the previous section.</p> <pre><code>cwlVersion: v1.2\n\n$graph:\n- class: Workflow\n  id: main\n  label: Water bodies detection based on NDWI and the otsu threshold\n  doc: Water bodies detection based on NDWI and otsu threshold applied to a single Sentinel-2 COG STAC item\n  requirements: []\n  inputs:\n    aoi:\n      label: area of interest\n      doc: area of interest as a bounding box\n      type: string\n    epsg:\n      label: EPSG code\n      doc: EPSG code\n      type: string\n      default: \"EPSG:4326\"\n    bands:\n      label: bands used for the NDWI\n      doc: bands used for the NDWI\n      type: string[]\n      default: [\"green\", \"nir\"]\n    item:\n      doc: Reference to a STAC item\n      label: STAC item reference\n      type: string\n  outputs:\n  ...\n  steps:\n    node_detect:\n      run: \"#detect-water-body\"\n      in:\n        item: item\n        aoi: aoi\n        epsg: epsg\n        band: bands\n      out:\n        - stac-catalog\n</code></pre> <p>For the outputs, the Workflow class includes the outputs section. This is a list of output fields where each field consists of an identifier and a data type.</p> <pre><code>cwlVersion: v1.2\n\n$graph:\n- class: Workflow\n  id: main\n  label: Water bodies detection based on NDWI and the otsu threshold\n  doc: Water bodies detection based on NDWI and otsu threshold applied to a single Sentinel-2 COG STAC item\n  requirements: []\n  inputs:\n    aoi:\n      label: area of interest\n      doc: area of interest as a bounding box\n      type: string\n    epsg:\n      label: EPSG code\n      doc: EPSG code\n      type: string\n      default: \"EPSG:4326\"\n    bands:\n      label: bands used for the NDWI\n      doc: bands used for the NDWI\n      type: string[]\n      default: [\"green\", \"nir\"]\n    item:\n      doc: Reference to a STAC item\n      label: STAC item reference\n      type: string\n  outputs:\n  - id: stac_catalog\n    outputSource:\n      - node_detect/stac-catalog\n    type: Directory\n  steps:\n    node_detect:\n      run: \"#detect-water-body\"\n      in:\n        item: item\n        aoi: aoi\n        epsg: epsg\n        band: bands\n      out:\n        - stac-catalog\n</code></pre>"},{"location":"best-practice/package/#application-additional-metadata","title":"Application Additional Metadata","text":"<p>The Application Package can include additional metadata in CWL descriptions and developers should provide a minimal amount of authorship information to encourage correct citation.</p> <p>It is recommended to include additional metadata in the Application Package using schema.org class Person to define the author and contributions and properties like citation, codeRepository, dateCreated and license as seen in the next example.</p> <pre><code>cwlVersion: v1.0\n$namespaces:\n  s: https://schema.org/\ns:softwareVersion: 1.0.0\nschemas:\n  - http://schema.org/version/9.0/schemaorg-current-http.rdf\n$graph:\n- class: Workflow\n  id: main\n  label: Water bodies detection based on NDWI and the otsu threshold\n  doc: Water bodies detection based on NDWI and otsu threshold applied to a single Sentinel-2 COG STAC item\n  ...\n</code></pre>"},{"location":"best-practice/package/#resources-for-the-runtime-environment","title":"Resources for the runtime environment","text":"<p>CWL provides a mechanism for expressing runtime environment resource requirements with the simple rule:</p> <ul> <li>min is the minimum amount of a resource that must be reserved to schedule a job. If min cannot be satisfied, the job should not be run.</li> <li>max is the maximum amount of a resource that the job shall be permitted to use. If a node has sufficient resources, multiple jobs may be scheduled on a single node provided each job\u2019s \"max\" resource requirements are met. If a job attempts to exceed its \"max\" resource allocation, an implementation may deny additional resources, which may result in job failure.</li> </ul> <p>Hardware resources are expressed with the CWL \"ResourceRequirement\" allowing the definition of:</p> <ul> <li>coresMin for the minimum reserved number of CPU cores</li> <li>coresMax for the maximum reserved number of CPU cores</li> <li>ramMin for the minimum reserved RAM in mebibytes</li> <li>ramMax for the maximum reserved RAM in mebibytes</li> </ul> <p>This definition covers most of the application resource requirements needs.\u200b</p> <p>If appropriate the Application Package can define resources for the runtime environment with ResourceRequirement class either at the level of each CommandLineTool classes or at the level of the Workflow class (that will be inherited to all CommandLineTool classes)</p> <pre><code>...\n- class: CommandLineTool\n  id: detect-water-body\n  requirements:\n      ResourceRequirement:\n        coresMax: 1\n        ramMax: 512\n...\n</code></pre>"},{"location":"best-practice/package/#hands-on","title":"Hands-on","text":"<p>Open the notebook 03 Package for a hands-on with a CWL runner</p>"},{"location":"best-practice/package/#requirement-classes","title":"Requirement classes","text":"<p>Requirement 7   req/app-pck/cwl</p> <p>The Application Package SHALL be a valid CWL document with a <code>Workflow</code> class and one or more <code>CommandLineTool</code> classes.</p> <p>Requirement 8   req/app-pck/clt</p> <p>The Application Package CWL <code>CommandLineTool</code> classes SHALL contain the following elements:</p> <ul> <li>Identifier (\"id\")</li> <li>Command line name (\"baseCommand\")</li> <li>Input parameters (\"inputs\")</li> <li>Environment requirements (\"requirements\")</li> <li>Docker information (\"DockerRequirement\")</li> </ul> <p>Requirement 9   req/app-pck/wf</p> <p>The Application Package CWL <code>Workflow</code> class SHALL contain the following elements:</p> <ul> <li>Identifier (\"id\")</li> <li>Title (\"label\")</li> <li>Abstract (\"doc\")</li> </ul> <p>Requirement 10 req/app-pck/wf-inputs</p> <p>The Application Package CWL <code>Workflow</code> class \"inputs\" fields SHALL contain the following elements:</p> <ul> <li>Identifier (\"id\")</li> <li>Title (\"label\")</li> <li>Abstract (\"doc\")</li> </ul> <p>Requirement 11 req/app-pck/metadata</p> <p>The Application Package CWL <code>Workflow</code> class classes SHALL include additional metadata as defined in the Table 1 of the OGC Best Practice for Earth Observation Application Package</p> <p>Recommendation 1 rec/app-pck/fan-out</p> <p>For applications with the fan-out design pattern, the Application Package CWL Workclass class MUST include the <code>ScatterFeatureRequirement</code> class in the <code>requirements</code> section and include the <code>scatterMethod</code> in the corresponding input of the step.</p>"},{"location":"cwl/cwl-eoap/","title":"CWL in the Best Practice for EO Application Package","text":"<p>In the scope of this Best Practice, the Application Package uses:</p> <ul> <li>the CWL Workflow Description specification as encoding to describe the Application, its parameters and data flows</li> <li>the CWL CommandLineTool for describing the command-line tools used, their arguments and their invocation within containers.</li> </ul> <p>With the use of CWL Workflow Description Standard as encoding, the Application can also possibly yield several Application Packages that expose parameters and inputs in different flavors and execution patterns.</p>"},{"location":"cwl/nutshell/","title":"Common Workflow Language","text":"<p>The Common Workflow Language (CWL) is a set of open standards for describing analysis workflows and tools in a way that makes them portable and scalable across a variety of software and hardware environments, from workstations to cluster, cloud, and high-performance computing (HPC) environments.</p> <p>The CWL targets data-intensive processing scenarios and makes these portable and scalable across platforms capable of interpreting and execute the processes by describing:</p> <ul> <li>A runtime environment</li> <li>A Workflow (Directed Acyclic Graph or \u201cDAG\u201d)</li> <li>Command line tool(s)</li> <li>Parameter of the process</li> <li>Inputs/outputs</li> </ul> <p>The CWL contains two main specifications:</p> <ul> <li>The <code>CommandLineTool</code> Description Specification that specifies the document schema and execution semantics for wrapping and executing command line tools </li> <li>The <code>Workflow</code> Description Specification that specifies the document schema and execution semantics for composing workflows from components such as command line tools and other workflows. </li> </ul> <p>The CWL file is able to reference the application container images and also allow the definitions of the Application parameters, input/output interface and the overall process offering parameters.</p> <p>Each input to a command line tool has a name and a type (e.g., File, string) and developers are encouraged to include documentation and labels for all components. Metadata about the command line tool descriptions can contain well-defined hints or mandatory requirements such as which software container to use or how much compute resources are required (memory, number of CPU cores, disk space, and/or the maximum time or deadline to complete the step or entire workflow.)</p> <p>The CWL execution model is explicit: each command line tool\u2019s runtime environment is explicit and any required elements must be specified by the CWL tool-description author (in contrast to hints, which are optional). Each tool invocation uses a separate working directory, populated according to the CWL tool description, e.g., with the input files explicitly specified by the workflow author. Some applications can expect particular filenames, directory layouts, and environment variables, and there are additional constructs in the CWL Command Line Tool standard to satisfy these needs.</p> <p>The CWL standards use a declarative syntax, facilitating polylingual workflow tasks. By being explicit about the run-time environment and any use of software containers, the CWL standards enable portability and reuse while also providing a separation of concerns between workflow authors and workflow platforms.</p> <p>The execution block (i.e. Application Artefact) describes the \u2018software\u2019 component that represents the execution unit in a specific container image to be executed or specific workflow script that can be invoked on the processor directly. Based on the context information provided with the processor, the execution block maps how the container image can be parameterized or tailored.</p> <p>A container image is an immutable, static file containing the dependencies for the creation of a container. These dependencies may include a single executable binary file, system libraries, system tools, environment variables, and other required platform settings (Cloud Native Glossary).</p> <p>In overall, a container image describes a container environment whereas a container is an instance of that environment, ran by a container engine (e.g. Docker Engine). It is possible to run multiple containers from the same image, and all of them will contain the same software and configuration, as specified in the image.</p> <p>There are multiple community or commercially supported systems that support the CWL standards for executing workflows and a list of free and open-source implementations of the CWL standards </p>"}]}